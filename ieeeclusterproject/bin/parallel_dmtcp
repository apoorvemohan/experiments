#!/usr/bin/env python

#total memory usage of all processes should be <= total memory of the system
#return list of processes to be exetuted next

import os
import sys
import time
import copy
import random
import signal
import subprocess as s
import multiprocessing as m
import xml.etree.ElementTree as ET

path = os.path.dirname(os.path.realpath(__file__))  + '/..'
sys.path.insert(0, path)

import common.imports.utils as u
import common.imports.constants as c
import common.imports.dmtcp_utils as du
import common.imports.rules as r

TIME = 60
MICRO_TIME = 10
timer = TIME
running_pid_port = []
app_stats_map = {}
stats_history_map = {}
total_passes = 0
running_history_map = {}
stats_map = {}
max_wall_time = 0
wall_count = 0
wtimer = 0

def get_next(totalthreads):
	global max_wall_time, wall_count, wtimer, stats_map
	next_runnable = {}
	max_wall_time = 0
	sorted_by_arrival = sorted(stats_map.items(), key=lambda x: x[1]['ARRIVAL'])

	for app in sorted_by_arrival:
		if wall_count != 0:
			if ((totalthreads - stats_map[app[0]]['THREADS']) >= 0) and (stats_map[app[0]]['WALL'] <= (max_wall_time - wtimer)):
				next_runnable.update({app[0]: stats_map[app[0]]['THREADS']})
				totalthreads -= stats_map[app[0]]['THREADS']
		else:
			wtimer = 0
			if ((totalthreads - stats_map[app[0]]['THREADS']) >= 0) :
				next_runnable.update({app[0]: stats_map[app[0]]['THREADS']})
				totalthreads -= stats_map[app[0]]['THREADS']
				if stats_map[app[0]]['WALL'] > max_wall_time:
					max_wall_time = stats_map[app[0]]['WALL']
			else:
				wall_count += 1
	return next_runnable

def get_queue_stats():
	global  stats_map
	runnable = get_runnable_instance_map().keys()
	for app in runnable:
		tree = ET.parse(c.PARALLEL_APP_INSTANCE_DIR + '/' + app + '.xml')
		root = tree.getroot()
		stats_map.update({app: {'THREADS':  int(root.findall('THREADS')[0].text)}})
		stats_map[app].update({'WALL':  int(root.findall('WALL')[0].text)})
		stats_map[app].update({'ARRIVAL':  int(root.findall('ARRIVAL')[0].text)})

def setup_for_restart(chkptdir):
        fp = open(chkptdir + '/dmtcp_env.txt', 'w')
        fp.write('STATFILE=$STATFILE\n')
        fp.write('STATGEN=$STATGEN\n')
        fp.close()

def get_runnable_instance_map():
        runnablemap = {}
	u.listonlydir(c.PARALLEL_DMTCP_CHKPTS_DIR).sort()
        for chkpt in u.listonlydir(c.PARALLEL_DMTCP_CHKPTS_DIR):
                chkptlist = u.listonlydir(c.PARALLEL_DMTCP_CHKPTS_DIR + '/' + chkpt)
                if len(chkptlist) > 0:
                        runnablemap.update({chkpt: c.PARALLEL_DMTCP_CHKPTS_DIR + '/' + chkpt + '/' + max(chkptlist) + '/' + u.getchkptimg(c.PARALLEL_DMTCP_CHKPTS_DIR + '/' + chkpt + '/' + max(chkptlist))})
                else:
                        u.logerr('INVALID CHKPT DIR ' + chkpt)

        return runnablemap

def update_app_stats_map(appid, statfile):
	fp = open(statfile, 'r')
	stats = fp.readlines()
	app_stats_map.update({appid : {}})
	app_stats_map[appid][stats[-2].split(':')[0].strip()] = float(stats[-2].split(':')[1].strip())
	app_stats_map[appid][stats[-1].split(':')[0].strip()] = float(stats[-1].split(':')[1].strip())
	for stat in stats[0:-3]:
		if stat.split(':')[0].strip() in ['CPU_CYCLES', 'INSTRUCTIONS', 'CACHE_REFERENCES', 'CACHE_MISSES', 'BRANCH_INSTRUCTIONS']:
			app_stats_map[appid][stat.split(':')[0].strip()] = float(stat.split(':')[1].strip())/app_stats_map[appid]['ELAPSED_TIME']
		else:
			app_stats_map[appid][stat.split(':')[0].strip()] = stat.split(':')[1].strip()
	fp.close()
	os.remove(statfile)

def generate_stats_and_enqueue():
	global app_stats_map, MICRO_TIME, stats_map, wtimer, wall_count
	runnable = get_runnable_instance_map()
	app_thread_pid = {}

	get_queue_stats()
	for app in runnable:
		tree = ET.parse(c.PARALLEL_DMTCP_APP_INSTANCE_DIR + '/' + app + '.xml')
		root = tree.getroot()
		app_thread_pid.update({app: [int(root.findall('THREADS')[0].text), None, str(app), None]})
	cpu = m.cpu_count()/2
	while len(app_thread_pid) > 0:

		next_runnable = get_next(cpu)

		#remove job with least threads if next_runnable size > 1
		if len(next_runnable) > 1:
			min_threads = 9999999
			min_threads_app = None
			for app in next_runnable.keys():
				if next_runnable[app] < min_threads:
					min_threads = next_runnable[app]
					min_threads_app = app
			next_runnable.pop(min_threads_app)

		for app in next_runnable.keys():
			stats_map.pop(app)

		for app in next_runnable.keys():
			
		#	if app_thread_pid[key][1] == None:

			u.loginfo('Executing ' + runnable[app])
			cwd = os.getcwd()
			os.chdir(c.PARALLEL_DMTCP_CHKPTS_DIR + '/' + str(app) + '/1')
			port = u.getopenport()
			u.loginfo('Restart1: ' + str(app))
			a = du.restart("taskset -c 0-" + str(m.cpu_count()/2 - 1) + ' ',runnable[app], '--new-coordinator', '--port ' + str(port), '--daemon', '-i ' + str(MICRO_TIME) , {'STATFILE': c.PARALLEL_DMTCP_QUEUED_DIR + '/' + app + '.stat', 'STATGEN' : ''})
			os.chdir(cwd)
			app_thread_pid[app][1] = a
			cpu -= app_thread_pid[app][0]

		flag = True
		while flag:
			time.sleep(1)
			wtimer += 1
			for app in app_thread_pid.keys():
				if (app_thread_pid[app][1] != None) and (app_thread_pid[app][1].poll() == 0):
					cpu = cpu + app_thread_pid[app][0]
					app_thread_pid.pop(app)
					flag = False
					if wall_count > 0:
						wall_count -= 1
					u.loginfo('Stop1: ' + str(app))
					stats_history_map.update({app:{}})
					stats_history_map[app].update({'INSTRUCTIONS':[]})
					stats_history_map[app].update({'CPU_CYCLES':[]})
					stats_history_map[app].update({'CACHE_MISSES':[]})
					stats_history_map[app].update({'ELAPSED_TIME':[]})
					stats_history_map[app].update({'CHECKPOINT_TIME':[]})
					update_app_stats_map(app, c.PARALLEL_DMTCP_QUEUED_DIR + '/' + str(app) + '.stat')
					app_stats_map[app]['TYPE'] = None
					app_stats_map[app]['pickup_count'] = 0
					stats_history_map[app]['INSTRUCTIONS'].append(app_stats_map[app]['INSTRUCTIONS'])
					stats_history_map[app]['CPU_CYCLES'].append(app_stats_map[app]['CPU_CYCLES'])
					stats_history_map[app]['CACHE_MISSES'].append(app_stats_map[app]['CACHE_MISSES'])
					stats_history_map[app]['ELAPSED_TIME'].append(app_stats_map[app]['ELAPSED_TIME'])
					stats_history_map[app]['CHECKPOINT_TIME'].append(app_stats_map[app]['CHECKPOINT_TIME'])

def get_next_runnable_map(retval):

	global app_stats_map, total_passes
	runningapplist = None

	for app in os.listdir(c.PARALLEL_DMTCP_RUNNING_DIR):
		update_app_stats_map(app.split('.')[0], c.PARALLEL_DMTCP_RUNNING_DIR + '/' + app)


	if ((len(sys.argv) == 1) or (sys.argv[1] == None) or (sys.argv[1] == '') or (sys.argv[1] == '-r') or (sys.argv[1] == '--random')):
		
		return random.choice(r.RULES.keys())(running_history_map, stats_history_map, app_stats_map, retval, runningapplist, total_passes)
	else:
		return r.RULES[sys.argv[1]](running_history_map, stats_history_map, app_stats_map, retval, runningapplist, total_passes)


def clean_completed(timer):
	global running_pid_port
	freed_threads = 0
	for app in running_pid_port:
		
		if (((timer != TIME) and (app[1].poll() == 0)) or ((timer == TIME) and (not os.path.exists(c.PARALLEL_DMTCP_RUNNING_DIR + '/' + app[0] + '.stat')))):
			os.system('touch ' + c.PARALLEL_DMTCP_COMPLETED_DIR + '/' + app[0] + '.' + u.gettimestamp().replace(' ', '_'))
			running_pid_port.remove(app)
			app_stats_map.pop(app[0])
			tree = ET.parse(c.PARALLEL_DMTCP_APP_INSTANCE_DIR + '/' + app[0] + '.xml')
			root = tree.getroot()
			freed_threads += int(root.findall('THREADS')[0].text)
			print "App Completed: " + str(app[0])

	return freed_threads

def stop_running(next_runnable):
	global running_pid_port

	for app in running_pid_port: 
		app[1].wait()
		stats_history_map[app[0]]['INSTRUCTIONS'].append(app_stats_map[app[0]]['INSTRUCTIONS'])
		stats_history_map[app[0]]['CPU_CYCLES'].append(app_stats_map[app[0]]['CPU_CYCLES'])
		stats_history_map[app[0]]['CACHE_MISSES'].append(app_stats_map[app[0]]['CACHE_MISSES'])
		stats_history_map[app[0]]['ELAPSED_TIME'].append(app_stats_map[app[0]]['ELAPSED_TIME'])
		stats_history_map[app[0]]['CHECKPOINT_TIME'].append(app_stats_map[app[0]]['CHECKPOINT_TIME'])

def start_next(next_runnable):
	global timer, stats_map
	to_restart = next_runnable[0]
	runnable = get_runnable_instance_map()

	cpu = m.cpu_count()/2
	disp = cpu
	
	for app in next_runnable[1]:
		cwd = os.getcwd()
		setup_for_restart(c.PARALLEL_DMTCP_CHKPTS_DIR + '/' + str(app) + '/1')
		port = u.getopenport()
		core_affinity = ''
		app_threads = stats_map[app]['THREADS']
		app_threads /= 2
		while app_threads > 0:
			core_affinity += (str(cpu - 1) + ',' + str(cpu - 1 + disp) + ',')
			cpu -= 1
			app_threads -= 1
		cmd = 'STATFILE=' + c.PARALLEL_DMTCP_RUNNING_DIR + '/' + app + '.stat' + ' ' + 'STATGEN= ' + 'taskset ' + core_affinity[:-1]  + ' ' + c.DMTCP_RESTART + ' --new-coordinator -i ' + str(timer) + ' --port ' + str(port) + ' ' + runnable[app]
		logfile = open(c.LOGDIR + '/' + c.LOGGER, 'a+')
		a = s.Popen(cmd, shell=True, stdout=logfile, stderr=logfile)
		running_pid_port.append([app, a, port])
		os.chdir(cwd)
		
	for app in list(set(next_runnable[0]) - set(next_runnable[1])):
		cwd = os.getcwd()
		setup_for_restart(c.PARALLEL_DMTCP_CHKPTS_DIR + '/' + str(app) + '/1')
		port = u.getopenport()
		cmd = 'STATFILE=' + c.PARALLEL_DMTCP_RUNNING_DIR + '/' + app + '.stat' + ' ' + 'STATGEN= ' + 'taskset -c 0-' +str(cpu - 1) + ' ' + c.DMTCP_RESTART + ' --new-coordinator -i ' + str(timer) + ' --port ' + str(port) + ' ' + runnable[app]
		logfile = open(c.LOGDIR + '/' + c.LOGGER, 'a+')
		print cmd
		a = s.Popen(cmd, shell=True, stdout=logfile, stderr=logfile)
		running_pid_port.append([app, a, port])
		os.chdir(cwd)

def main():
	import time
	global running_pid_port, app_stats_map, total_passes, app_stats_map, running_history, TIME

	if os.path.isdir(c.PARALLEL_DMTCP_STATS_DIR):
                os.rename(c.PARALLEL_DMTCP_STATS_DIR, c.PARALLEL_DMTCP_STATS_DIR + '.' + u.gettimestamp().replace(' ', '_'))

	os.mkdir(c.PARALLEL_DMTCP_STATS_DIR)
	os.mkdir(c.PARALLEL_DMTCP_COMPLETED_DIR)
	os.mkdir(c.PARALLEL_DMTCP_RUNNING_DIR)
	os.mkdir(c.PARALLEL_DMTCP_QUEUED_DIR)
	os.mkdir(c.PARALLEL_DMTCP_NOIDEA_DIR)

	generate_stats_and_enqueue()

	if(sys.argv[1] == '-b'):
		sys.exit(0)

	print 'Stats Generated and Tasks Enqueued!!!'
	timer = 0

	total_passes = 0
	micro_passes = 0
	while(len(app_stats_map) > 0):
		micro_passes += 1
		if timer == 0:
			print 'time to stop'
			stop_running([])
			timer = TIME

		completed = clean_completed(timer)

		if timer == TIME:
			del running_pid_port[:]
			running_pid_port[:] = []
			if completed > 0:
				print 'Some app completed after midway'
				completed = None
			elif completed == 0:
				completed = -1
				print 'No App completed at the end of the interval'

		if (timer >= (MICRO_TIME*3)) and (completed != 0):
				print timer
				print completed
				if completed > 0:
					print 'Some app completed before midway'
#			if (completed == None) or ((completed != 0) and (completed != None)):
				next_runnable = get_next_runnable_map(completed)
				total_passes = total_passes + 1
				if (completed == -1) or (completed == None):
					u.loginfo('Next Runnable List: ' + str(next_runnable))
					running_history_map[total_passes] = next_runnable
				else:
					u.loginfo('Appending new job to current running: ' + str(next_runnable))
					running_history_map[total_passes] = [[],[]]

					for app in next_runnable[0]:
						running_history_map[total_passes][0].append(app)

					for app in running_history_map[total_passes - 1][0]:
						if app in app_stats_map:
							running_history_map[total_passes][0].append(app)

				start_next(next_runnable)
		u.loginfo(running_history_map)
		print running_history_map
		time.sleep(MICRO_TIME)
		timer -= MICRO_TIME

	u.loginfo('Micro Count: ' + str(micro_passes))

if __name__ == "__main__":
	c.LOGGER = 'parallel_dmtcp_a.log'
	u.loginfo('Begin Time:  ' + u.gettimestamp())
	main()
	u.loginfo('End Time:  ' + u.gettimestamp())
