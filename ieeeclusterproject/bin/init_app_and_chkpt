#!/usr/bin/env python

import os
import time
import sys
import multiprocessing as m
import xml.etree.ElementTree as ET
import copy
import datetime

path = os.path.dirname(os.path.realpath(__file__))  + '/..'
sys.path.insert(0, path)

import common.imports.utils as u
import common.imports.constants as c
import common.imports.dmtcp_utils as du

stats_map = {}
max_wall_time = 0
wall_count = 0
wtimer = 0
runnable = {}

def get_next(totalthreads):
	global max_wall_time, wall_count, wtimer, stats_map
	next_runnable = {}
	max_wall_time = 0
	sorted_by_arrival = sorted(stats_map.items(), key=lambda x: x[1]['ARRIVAL'])

	for app in sorted_by_arrival:
		if wall_count != 0:
			if ((totalthreads - stats_map[app[0]]['THREADS']) >= 0) and (stats_map[app[0]]['WALL'] <= (max_wall_time - wtimer)):
				next_runnable.update({app[0]: stats_map[app[0]]['THREADS']})
				totalthreads -= stats_map[app[0]]['THREADS']
		else:
			wtimer = 0
			if ((totalthreads - stats_map[app[0]]['THREADS']) >= 0) :
				next_runnable.update({app[0]: stats_map[app[0]]['THREADS']})
				totalthreads -= stats_map[app[0]]['THREADS']
				if stats_map[app[0]]['WALL'] > max_wall_time:
					max_wall_time = stats_map[app[0]]['WALL']
			else:
				wall_count += 1

	for app in next_runnable.keys():
		stats_map.pop(app)

	return next_runnable

def get_queue_stats():
	global runnable, stats_map
	for app in runnable.keys():
		tree = ET.parse(c.PARALLEL_APP_INSTANCE_DIR + '/' + app + '.xml')
		root = tree.getroot()
		stats_map.update({app: {'THREADS':  int(root.findall('THREADS')[0].text)}})
		stats_map[app].update({'WALL':  int(root.findall('WALL')[0].text)})
		stats_map[app].update({'ARRIVAL':  int(root.findall('ARRIVAL')[0].text)})

def setup_for_restart(chkptdir):
	fp = open(chkptdir + '/dmtcp_env.txt', 'w')
	fp.write('STATFILE=$STATFILE\n')
	fp.write('STATGEN=$STATGEN\n')
        fp.close()

def get_runnable_instance_map(appinstancedir):
        runnable_instance_map = {}
        for instance in os.listdir(appinstancedir):
                runnable_instance_map.update(u.getidcmdpairbyxml(appinstancedir + '/' + instance))
        return runnable_instance_map

def main():

	global wall_count, wtimer, runnable, stats_map

	CHKPTDIR = None
	APPINSTANCEDIR = None

	if (len(sys.argv) == 1) or (sys.argv[1] == ''):
		u.logerr('INVALID ARGUMENT SUPPLIED!!!')
		sys.exit(0)

	if (sys.argv[1] == '-s') or (sys.argv[1] == '--seq'):
		CHKPTDIR = c.SEQ_DMTCP_CHKPTS_DIR
		APPINSTANCEDIR = c.SEQ_DMTCP_APP_INSTANCE_DIR
	elif (sys.argv[1] == '-p') or (sys.argv[1] == '--parallel'):
                CHKPTDIR = c.PARALLEL_DMTCP_CHKPTS_DIR
                APPINSTANCEDIR = c.PARALLEL_DMTCP_APP_INSTANCE_DIR

	if os.path.isdir(CHKPTDIR):
		os.rename(CHKPTDIR, CHKPTDIR + '.' + u.gettimestamp().replace(' ', '_'))
		u.loginfo('chkpt dir archieved')
	os.mkdir(CHKPTDIR)

	runnable = get_runnable_instance_map(APPINSTANCEDIR)

	get_queue_stats()
	if (sys.argv[1] == '-p') or (sys.argv[1] == '--parallel'):

		app_thread_pid = {}

		for app in runnable.keys():
			tree = ET.parse(c.PARALLEL_DMTCP_APP_INSTANCE_DIR + '/' + app + '.xml')
			root = tree.getroot()
			app_thread_pid.update({app: [int(root.findall('THREADS')[0].text), None]})

		cpu = m.cpu_count()/2

		while len(app_thread_pid) > 0:

			next_runnable = get_next(cpu)
			for app in next_runnable.keys():
				
					u.loginfo('[Starting ' + app + ' : ' + runnable[app] + ']')
					os.mkdir(CHKPTDIR + '/' + str(app))
					u.execcmd('touch ' + CHKPTDIR + '/' + str(app) + '/command')
					u.execcmd('echo \"' + runnable[app] + '\" >> ' + CHKPTDIR + '/' + str(app) + '/command')
					if not os.path.isdir(CHKPTDIR + '/' + str(app) + '/1'):
						os.mkdir(CHKPTDIR + '/' + str(app) + '/1')

					port = None
					cwd = u.getcwd()

					if (sys.argv[1] == '-p') or (sys.argv[1] == '--parallel'):
						setup_for_restart(CHKPTDIR + '/' + str(app) + '/1')

					u.chdir(CHKPTDIR + '/' + str(app) + '/1')
					os.system('cp ' + c.BASE + '/random.in .')
					port = u.getopenport()

					u.loginfo('Launching App: ' + str(app))

					a = du.launch("taskset -c 0-" + str(m.cpu_count()/2) + " ", runnable[app], '--with-plugin myplug', '--newcoordinator', '--port ' + str(port), '--modify-env', '--daemon', '-i 5', {'STATFILE': '', 'STATGEN' : ''})
					u.loginfo('after launch: ' + str(app))
					u.chdir(cwd)
					app_thread_pid[app][1] = a
					cpu -= app_thread_pid[app][0]
			flag = True

			while flag:
				time.sleep(2)
				wtimer += 2

				for app in app_thread_pid.keys():
					if (app_thread_pid[app][1] != None) and (app_thread_pid[app][1].poll() == 0):
					#if (app_thread_pid[app][1].poll() == 0):
						cpu = cpu +  app_thread_pid[app][0]
						flag = False
						if wall_count > 0:
							wall_count -= 1
						u.loginfo('App Finished: ' + str(app))
						app_thread_pid.pop(app)


if __name__ == '__main__':
	c.LOGGER = 'init_app_and_chkpt_a.log'
	u.loginfo('Begin Time:  ' + u.gettimestamp())
	main()
	u.loginfo('End Time:  ' + u.gettimestamp())

