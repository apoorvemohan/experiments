#!/usr/bin/env python

import os
import sys
import copy
import time
import random
import signal
import subprocess
import multiprocessing as m
import xml.etree.ElementTree as ET

path = os.path.dirname(os.path.realpath(__file__))  + '/..'
sys.path.insert(0, path)

import common.imports.utils as u
import common.imports.constants as c

totalthreads = 0
groupthreads = 0
runnable_map = {}
runnable = []
app_statfile_list = []
app_stats_map = {}
max_wall_time = 0
wall_count = 0
timer = 0

def get_next(totalthreads):
	global max_wall_time, wall_count, timer, app_stats_map
	next_runnable = {}
	max_wall_time = 0
	sorted_by_arrival = sorted(app_stats_map.items(), key=lambda x: x[1]['ARRIVAL'])
	print 'Sortyed by arrival Time: ' + str(sorted_by_arrival)

	for app in sorted_by_arrival:
		if wall_count != 0:
			if ((totalthreads - app_stats_map[app[0]]['THREADS']) >= 0) and (app_stats_map[app[0]]['WALL'] <= (max_wall_time - timer)):
				next_runnable.update({app[0]: app_stats_map[app[0]]['THREADS']})
				totalthreads -= app_stats_map[app[0]]['THREADS']
		else:
			timer = 0
			if ((totalthreads - app_stats_map[app[0]]['THREADS']) >= 0) :
				next_runnable.update({app[0]: app_stats_map[app[0]]['THREADS']})
				totalthreads -= app_stats_map[app[0]]['THREADS']
				if app_stats_map[app[0]]['WALL'] > max_wall_time:
					max_wall_time = app_stats_map[app[0]]['WALL']
			else:
				wall_count += 1

	for app in next_runnable.keys():
		app_stats_map.pop(app)

	return next_runnable

def get_queue_stats():
	global runnable, app_stats_map
	for app in runnable:
		tree = ET.parse(c.PARALLEL_APP_INSTANCE_DIR + '/' + app + '.xml')
		root = tree.getroot()
		app_stats_map.update({app: {'THREADS':  int(root.findall('THREADS')[0].text)}})
		app_stats_map[app].update({'WALL':  int(root.findall('WALL')[0].text)})
		app_stats_map[app].update({'ARRIVAL':  int(root.findall('ARRIVAL')[0].text)})
		

def get_group_map(runnablemap):
	groupmap = {}
	for grp in os.listdir(c.PARALLEL_GROUPS_DIR):
			tree = ET.parse(c.PARALLEL_GROUPS_DIR + '/' + grp)
			root = tree.getroot()
			groupmap.update({root.get('ID'): []})
			for app in root.getchildren():
				groupmap[root.get('ID')].append(app.text)
	return groupmap

def get_runnable_instance_map():
	runnable_instance_map = {}
	for instance in os.listdir(c.PARALLEL_APP_INSTANCE_DIR):
		runnable_instance_map.update(u.getidcmdpairbyxml(c.PARALLEL_APP_INSTANCE_DIR + '/' + instance))
	return runnable_instance_map

def main():

	global totalthreads, groupthreads, runnable_map, runnable, app_statfile_list, app_stats_map, max_wall_time, wall_count, timer
	if os.path.isdir(c.PARALLEL_STATS_DIR):
		os.rename(c.PARALLEL_STATS_DIR, c.PARALLEL_STATS_DIR + '.' + u.gettimestamp().replace(' ', '_'))
	os.mkdir(c.PARALLEL_STATS_DIR)

	#signal.signal(signal.SIGCHLD, signal.SIG_IGN) 
	runnable_map = get_runnable_instance_map()
	runnable = runnable_map.keys()

	get_queue_stats()

	if (sys.argv[1] == '-r') or (sys.argv[1] == '--random'):
		tree = ET.parse(c.PARALLEL_RANDOM_DIR + '/R.xml')
		root = tree.getroot()
		maxthreads = root.findall('MAXTHREADS')
		overcommitfactor = root.findall('TOVERCOMMIT')

		if ((len(maxthreads) > 0) and (len(overcommitfactor) > 0)):
			totalthreads = random.choice([float(maxthreads[0].text), float(overcommitfactor[0].text) * float(m.cpu_count()/2)])
		elif (len(maxthreads) > 0):
			u.loginfo("No Overcommitment Specified. MAXTHREADS")
			totalthreads = float(maxthreads[0].text)
		elif (len(overcommitfactor) > 0):
			u.loginfo("No Maxthread Specified.")
			totalthreads = float(overcommitfactor[0].text) * float(m.cpu_count()/2)

		if (int(totalthreads) == 0):
			u.loginfo('zero threads')
			sys.exit(0)

		totalthreads = int(totalthreads)
		u.loginfo("Total Threads Selected: " + str(totalthreads))
		os.mkdir(c.PARALLEL_STATS_DIR + '/R')

		appthreads = appid = statfile = status = None

		while len(runnable_map) > 0:
			print 'Runnable Map: ' + str(runnable_map)
			next_runnable = None
			next_runnable = get_next(totalthreads)
			print 'Next_Runnable: ' + str(next_runnable)
			print 'Available Threads: ' + str(totalthreads)
			for app in next_runnable.keys():
				timestamp = u.gettimestamp().replace(' ', '_')
				statfile = status = None
				statfile = open(c.PARALLEL_STATS_DIR + '/R/' + str(app) + '_' + timestamp + '.stat','a')
				statfile.write(runnable_map[app])
				u.loginfo('Executing: perf stat ' + runnable_map[app])
				u.loginfo('Executing appid: ' + str(app))
				cmd = ''
				if 'WATER-NSQUARED' in runnable_map[app]:
					cmd = runnable_map[app].split(";")[0] + ' ; taskset -c 0-3,16-19,28-31,12-15 ' + runnable_map[app].split(";")[1] + ' >> ' + c.LOGDIR + '/' + c.LOGGER + ' 2>&1'
				else:
					cmd = 'taskset -c 0-3,16-19,28-31,12-15 ' + runnable_map[app] + ' >> ' + c.LOGDIR + '/' + c.LOGGER + ' 2>&1'

				print cmd
				status = subprocess.Popen(cmd, shell=True, stdout=statfile, stderr=statfile)
				app_statfile_list.append([status, statfile, app, next_runnable[app]])
				totalthreads -= next_runnable[app]

			print "Remaining Thread: " + str(totalthreads)
			print app_statfile_list

			flag = True
			while flag:
				time.sleep(5)
				timer += 5

				for app in [app_statfile_list][0]:
					if (app[0] != None) and (app[0].poll() == 0):
						app_statfile_list.remove(app)
						u.loginfo('App id completed: ' + str(app[2]))
						runnable_map.pop(app[2])
						totalthreads += app[3]
						u.loginfo('Number of threads freed: ' + str(app[3]))
						app[1].close()
						flag = False
						if wall_count > 0:
							wall_count -= 1


		if groupthreads != 0:
			u.logwarn("Group Threads Not ZERO at end: " + str(groupthreads))

	elif (sys.argv[1] == '-d') or (sys.argv[1] == '--defined'):

		groupmap = get_group_map(copy.deepcopy(runnable_map))
				
if __name__ == "__main__":
	c.LOGGER = 'parallel_16_on_16_two_chip.log'
	u.loginfo('Begin Time:  ' + u.gettimestamp())
	main()
	u.loginfo('End Time:  ' + u.gettimestamp())
